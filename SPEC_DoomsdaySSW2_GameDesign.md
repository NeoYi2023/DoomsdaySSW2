# DoomsdaySSW2 游戏技术规范文档 (SPEC)

## 文档版本
- **版本号**: v1.0
- **创建日期**: 2024-12-10
- **项目名称**: DoomsdaySSW2
- **游戏类型**: 回合制探索收集 + 避难所建造 + 卡牌构建
- **开发引擎**: Unity 2021.3.40f1

---

## 1. 项目概述

### 1.1 游戏核心玩法
一款以回合制探索、资源收集、避难所建造和卡牌构建为核心玩法的末日生存游戏。玩家需要管理探险者队伍，在地图上探索采集点，收集资源，扩建避难所，并应对僵尸威胁。

### 1.2 核心循环
1. **准备阶段**: 每次出发前选择探险者组成探险队（**至少1人，最多3人**），每次出发均需要重新选择
2. **探索阶段**: 选择目标点，前往采集点进行探索
3. **战斗/收集阶段**: 在探索点中收集资源、躲避或消灭僵尸
4. **返回阶段**: 返回避难所保存资源
5. **建设阶段**: 使用资源扩建避难所、升级角色
6. **回合推进**: 点击"下一回合"进入下一轮循环

---

## 2. 时间系统设计

### 2.1 时间规则
- **回合时长**: 每个回合 = 30分钟（游戏内时间）
- **游戏内1天**: 48个回合（24小时 × 2回合/小时）
- **时间推进**: 手动触发，玩家点击"下一回合"才推进
- **暂停状态**: 未点击"下一回合"时，时间暂停，但回合内逻辑继续运行

### 2.2 时间段划分
| 时间段 | 时间范围 | 回合范围（刻度索引） | 特殊规则 |
|--------|----------|----------------------|----------|
| **白天** | 06:00 - 18:00 | 刻度 12-35（共24格） | 正常探索，僵尸出现率低 |
| **傍晚** | 18:00 - 22:00 | 刻度 36-43（共8格） | 僵尸出现率中等 |
| **深夜** | 22:00 - 次日06:00 | 刻度 44-47 + 0-11（共16格） | 返回路径大概率遇到僵尸 |

> 刻度索引从 0 开始，每格代表 30 分钟（1回合）。UI 上使用不同颜色区分时间段：白天（白色）、傍晚（橙色）、深夜（紫色）。

### 2.3 时间系统数据结构
```csharp
// 伪代码结构
TimeSystem {
    int currentRound;          // 当前回合数 (0-47)
    int currentDay;            // 当前天数
    TimePeriod currentPeriod;  // 当前时间段 (Day/Evening/Night)
    bool isPaused;             // 是否暂停
    float roundDuration;       // 回合时长（30分钟）
}
```

---

## 3. 回合系统设计

### 3.1 回合运作流程
```
进入新回合（在回合开始时统一结算体力）
    ↓
临时背包恢复锁定状态并清空（上一回合的临时背包物品丢失，`isTempInventoryLocked = true`）
    ↓
角色状态刷新（体力-1，状态恢复等；**体力扣除仅在此处结算一次**）
    ↓
地点状态和配置刷新（资源刷新、怪物刷新等）
    ↓
根据当前所在位置与状态分支处理：
    ├─ 若在**大地图上且已选择目标点**：本回合在大地图上朝目标点移动1格
    └─ 若当前位于**探索点内部（探索空间中）**：本回合停留在原地，仅在探索空间内进行行动或层数推进，不进行大地图移动
    ↓
探险内计算（移动、探索、战斗等；不再额外扣除“每回合-1”的体力）
    ↓
玩家可手动使用道具
    ↓
玩家可整理背包（如果临时背包已解锁，可在角色背包和临时背包间移动物品）
    ↓
玩家可选择"撤退"返回避难所（可在任意回合选择，详见7.5返回避难所机制）
    ↓
玩家主动点击"下一回合"（进入下一回合，临时背包恢复锁定并清空）
```

### 3.2 回合状态机
- **RoundStart**: 回合开始
- **StateRefresh**: 状态刷新
- **LocationRefresh**: 地点刷新
- **Exploration**: 探索阶段
- **PlayerAction**: 玩家操作阶段
- **RoundEnd**: 回合结束（等待玩家点击下一回合）

---

## 4. 地图系统设计

### 4.1 地图网格系统
- **基础单位**: 格子（Grid Cell）
- **坐标系统**: 
  - 地图使用 X/Y 坐标系统
  - UI 渲染时，X 轴为垂直方向（行），Y 轴为水平方向（列）
  - 即：外层循环 X（每行一个 X 值），内层循环 Y（每列一个 Y 值）
- **移动规则**: 每回合在大地图上移动1格（仅当队伍处于大地图状态且设置了目标点时生效；当队伍正在探索点内部时，本回合不进行大地图格子的移动）
- **寻路规则**: 使用 BFS（广度优先搜索）进行 4 向寻路（上下左右），避开不可通行的格子
- **格子类型**: 
  - 避难所（Shelter）：可通行，探险队起始点和返回目标
  - 道路（Road）：可通行
  - 探索点（Exploration Point）：可通行，可进入探索
  - 空地（Empty）：可通行
  - 已建设地点（Built Location）：**不可通行**，寻路时需绕开

### 4.2 格子状态转换
```
探索点 (Exploration Point)
    ↓ [探索进度达到100%]
空地 (Empty)
    ↓ [满足建设条件 + 玩家操作]
已建设地点 (Built Location)
```

### 4.3 格子数据结构
```csharp
GridCell {
    CellType type;              // 格子类型
    Vector2Int position;         // 坐标位置
    ExplorationState exploreState; // 探索状态
    int explorationProgress;     // 探索进度 (0-100)，由当前层数 / 最大层数计算，例如 explorationProgress = currentLayer / maxLayers * 100
    bool canBuild;               // 是否可建设
    BuildingType buildingType;   // 建设类型（如果已建设）
    List<Resource> resources;    // 资源列表
    List<Monster> monsters;      // 怪物列表
    TimePeriod spawnTime;        // 生成时间段
    
    // 角色死亡物品存储（详见8.4角色死亡处理）
    List<Item> droppedItems;     // 死亡角色掉落的物品列表
    int deathRound;              // 角色死亡时的回合数（用于计算96回合过期）
    string deadExplorerId;       // 死亡角色的ID（用于显示和标识）
}
```

### 4.4 地图配置
- **地图大小**: 可配置（建议初始50x50）
- **初始避难所位置**: 地图中心或指定坐标
- **探索点分布**: 策划配置表控制
- **道路连接**: 格子之间的移动路径

---

## 5. 探险者系统设计

### 5.1 探险者基础属性
| 属性 | 初始值 | 说明 |
|------|--------|------|
| **最大血量 (Max HP)** | 3点 | 角色的血量上限 |
| **初始血量 (Initial HP)** | 3点 | 角色首次被创建/解锁并加入玩家列表时的初始血量，用于初始化 currentHP，默认等于最大血量 |
| **最大体力 (Max Stamina)** | 48点 | 角色的体力上限，每30分钟消耗1点，0时技能效果-50% |
| **初始体力 (Initial Stamina)** | 48点 | 角色首次被创建/解锁并加入玩家列表时的初始体力，用于初始化 currentStamina，默认等于最大体力 |
| **攻击力 (Attack)** | 1点 | 优先攻击怪物 |
| **背包格子数量 (Inventory Slots)** | 待配置 | 角色背包可用格子总数。背包采用“格子+堆叠”模式：一种道具/资源在未超过该物品单格堆叠上限前，只占用1格；只有当该格的堆叠数量达到配置的最大堆叠数量后，新增同类物品才会占用新的格子。 |

### 5.2 角色状态
- **正常 (Normal)**: 血量 > 0
- **濒死 (Dying)**: 血量 = 0，回合结束前可治疗
- **死亡 (Dead)**: 回合结束时未治疗
- **疲劳 (Exhausted)**: 体力 = 0

### 5.3 天赋系统
- **定义**: 角色初始拥有的技能或Buff
- **升级方式**: 消耗专属道具
- **配置方式**: 配置表设置
- **效果类型**: 
  - 被动技能
  - 属性加成
  - 特殊能力

### 5.4 科技树系统

#### 5.4.1 科技树分支
1. **体魄 (Physique)**
   - 增加战斗力
   - 增加背包容量
   - 增加耐力/体力上限
   - 增加血量上限

2. **智力 (Intelligence)**
   - 增加资源搜集种类
   - 增加收集数量
   - 解锁高级资源采集
   - 提升资源识别能力

3. **谋略 (Strategy)**
   - 增加探索效率
   - 解锁特殊能力
   - 提升战斗策略
   - 增加探索发现概率

#### 5.4.2 科技树解锁方式
- **方式1**: 消耗"科技点"主动选择
- **方式2**: 消耗专属道具定向解锁
- **配置**: 每个角色有专属科技树配置

### 5.5 末日前身份标签
- **作用**: 角色专属科技树的概括
- **影响**: 决定初始天赋和初始解锁的科技项
- **配置**: 配置表设置

### 5.6 探险者数据结构
```csharp
Explorer {
    string id;                   // 角色ID
    string name;                 // 角色名称
    string preApocalypseIdentity; // 末日前身份标签
    
    // 基础属性
    int maxHP;                   // 最大血量
    int currentHP;               // 当前血量
    int maxStamina;              // 最大体力
    int currentStamina;          // 当前体力
    int initialHP;               // 初始血量：角色首次创建/解锁并加入玩家列表时，用于赋值 currentHP，默认 = maxHP
    int initialStamina;          // 初始体力：角色首次创建/解锁并加入玩家列表时，用于赋值 currentStamina，默认 = maxStamina
    int attack;                  // 攻击力
    int inventoryCapacity;       // 背包格子数量（可用格子总数，采用格子+堆叠模式）
    
    // 系统
    List<Talent> talents;        // 天赋列表
    TechTree techTree;           // 科技树
    List<Item> inventory;        // 背包物品
    
    // 状态
    ExplorerStatus status;       // 角色状态
    bool isUnlocked;            // 是否解锁（测试阶段默认全部解锁）
}
```

> 所有探险者的初始数值（最大/初始血量与体力、攻击力等），必须通过角色配置表 ExplorerConfig 加载，不允许在代码中硬编码具体数值。

---

## 6. 探险队系统设计

### 6.1 队伍组成规则
- **最大人数**: 3人
- **选择位置**: 从避难所出发前选择
- **队伍状态**: 
  - 在避难所（可更换成员）
  - 探索中（不可更换）
  - 返回中（不可更换，正在返回避难所的移动过程中）
  - 在大地图上（已有探险队在外时，不可更换成员，只能控制当前探险队前往新目标点）

### 6.2 探险队位置持久化规则
- **位置保持**: 探险队在大地图上的位置在整个探索过程中持续保持，不会因为进入/退出探索点而重置
- **从当前位置出发**: 当探险队已在大地图上时（非在避难所），选择新目标点后从当前位置出发，而非从避难所出发
- **时间连续**: 探险队在地图上移动、进入探索点、退出探索点的过程中，回合数（时间）连续累计，不会重置
- **成员锁定**: 探险队在外探索时，成员固定不可更换，直到返回避难所
- **当前位置交互**: 
  - 探险队位于某探索点时，点击该探索点可直接进入探索（无需移动）
  - 探险队位于大地图时，点击其他探索点会弹出成员确认界面（成员锁定显示），确认后开始移动

### 6.3 队伍数据结构
```csharp
ExpeditionTeam {
    List<Explorer> members;      // 成员列表（最多3人），按选择顺序排序
    Vector2Int currentPosition;   // 当前位置
    Vector2Int targetPosition;    // 目标位置
    ExpeditionStatus status;      // 队伍状态
    int currentRound;             // 当前回合数
    List<Item> tempInventory;     // 临时背包：本回合无法放入角色背包的物品
    bool isTempInventoryLocked;  // 临时背包锁定状态：true=锁定（玩家无法打开），false=解锁（玩家可以打开）
}
```

> 注意：每个角色的背包是独立的，存储在 `Explorer.inventory` 中，不存在"队伍共享背包"的概念。

### 6.4 背包使用规则
- **背包独立性**: 探索队中每个角色的背包独立，互不共享
- **背包容量判定**: 每个角色有固定的背包格子数量 `inventoryCapacity`（从 `ExplorerConfig` 加载）。当该角色背包中已有的“占用格子数” < `inventoryCapacity` 时，仍视为有空格；当占用格子数 ≥ `inventoryCapacity` 时，视为背包已满。
- **物品堆叠规则**: 
  - 每个物品/资源都有"堆叠最大数量"属性（在 `ItemConfig` 中配置）
  - 背包中1个格子最多可以堆叠该物品的堆叠最大数量
  - 超过堆叠最大数量的部分必须存放在新的格子上
  - 如果所有角色背包都没有空格子，则放入本回合的"临时背包"中
- **资源分配规则**: 
  - 当采集获得道具或资源时，按照小队中角色的排序（第1名、第2名、第3名）进行分配
  - 优先放入第1名队员的背包，如果第1名队员背包已满，则放入第2名队员的背包
  - 如果第2名队员背包也已满，则放入第3名队员的背包
  - 如果所有队员背包都已满，则放入临时背包
- **临时背包规则**: 
  - **锁定状态**：临时背包在正常状态下处于锁定状态（`isTempInventoryLocked = true`），玩家无法主动打开临时背包界面
  - **解锁条件**：只有当玩家在探索中获得道具/资源并尝试放入角色背包时，遇到"所有角色背包空间不足"的情况，临时背包才会自动解锁（`isTempInventoryLocked = false`），并将未能放入角色背包的道具放入临时背包中
  - **解锁后的使用**：临时背包解锁后，玩家可以在角色背包和临时背包之间互换物品位置，也可以从临时背包中取出物品放入角色背包
  - **回合结束处理**：进入下一回合时，临时背包将恢复锁定状态（`isTempInventoryLocked = true`）并清空临时背包内的所有物品（物品丢失）
  - **建议**：玩家应在回合结束前将临时背包中的重要物品移入角色背包，避免物品丢失
- **资源移动规则**: 
  - 玩家可以在探索过程中手动挪动背包中资源的存放位置
  - 可以在不同角色之间移动资源（前提是目标角色背包有空间）
  - 如果临时背包已解锁，可以在角色背包和临时背包之间移动资源
  - 资源移动操作不消耗回合或体力
- **物品丢弃规则**: 
  - 玩家可以整体丢弃背包中的物品（包括堆叠的物品，丢弃时整个格子清空）
  - 丢弃操作不消耗回合或体力
  - 丢弃的物品将永久消失，无法恢复
  - 建议在丢弃操作时提供二次确认，避免误操作
- **物品拆分规则**（低优先级功能）: 
  - 玩家可以将背包中堆叠的物品拆分为指定数量
  - 拆分后的物品需要放到一个空格子上（目标格子必须为空）
  - 拆分操作不消耗回合或体力
  - 拆分数量不能超过原格子的堆叠数量，也不能超过该物品的堆叠最大数量

---

## 7. 探索系统设计

### 7.1 探索流程
```
选择目标点（在地图上）
    ↓
从避难所出发
    ↓
每回合移动1格
    ↓
到达目标格子
    ↓
触发探索玩法（如果格子类型为"探索点"）
    ↓
进入第1层探索棋盘（6x4格子）
    ↓
刷新角色、怪物、垃圾
    ↓
进行探索操作（移动、采集、战斗）
    ↓
完成当前层探索（只要还有至少1个角色存活即可判定完成，或玩家主动退出）
    ↓
判断是否达到最大层数
    ├─ 未达到：进入下一层（层数+1），重新生成探索棋盘
    └─ 已达到：强制结束探索，返回地图界面，玩家需手动选择下一个目标点
    ↓
（如果未达到最大层数）继续下一层探索
    ↓
（如果达到最大层数）返回避难所或选择新目标点
    ↓
（可选）玩家可在任意时刻选择"撤退"返回避难所（详见7.5返回避难所机制）
```

### 7.2 探索棋盘生成
- **棋盘大小**: 6格宽 × 4格高（24个格子）
- **层数机制**: 
  - 每个探索点配置有最大层数（`maxLayers`），在 `ExplorationPointConfig` 中独立配置
  - 每次进入探索点时，从第1层开始
  - 每探索完当前层（满足 7.3 的探索完成条件）后，自动进入下一层（层数+1），并重新生成新的探索棋盘
  - 达到最大层数后，强制结束该探索点的探索，返回地图界面，玩家需手动选择下一个目标点
- **生成顺序**: 
  1. **角色放置**：从当前探险队中筛选出仍然存活的角色，将其随机放置在探索棋盘上允许的角色起始区域（例如上方若干行，具体由配置决定）；若存活角色少于起始格数量，剩余起始格保持为空
  2. **棋盘内容放置（怪物与垃圾）**：在角色放置完成后，对棋盘上剩余的空格子按照格子编号由小到大遍历：
     - 从 `ExplorationPointConfig` 中读取该探索点的“棋盘出现内容”配置字段，该字段包含若干条以竖线 `|` 分隔的配置项，每项格式为：`出现类型_具体ID_出现权重值`，例如：`Monster_monster_zombie_10|Garbage_garbage_trash_5`
     - 将每一条配置项视为一个候选单位，根据其“出现权重值”进行加权随机筛选，决定当前格子生成哪一种单位（如怪物 / 垃圾 / 留空）
     - 当“出现类型”为 `Monster` 时，以 `具体ID` 在 `MonsterConfig` 中查找并生成怪物实例；当“出现类型”为 `Garbage` 时，以 `具体ID` 在 `ResourceConfig` 中查找并生成垃圾（可采集资源）实例；若后续扩展其他类型（如陷阱等），按同样方式处理

> 探索棋盘中怪物与垃圾的生成规则（种类、数量、概率等），完全由配置表（如 ExplorationPointConfig 的“棋盘出现内容”、MonsterConfig、ResourceConfig 等）驱动，代码只根据配置 ID 和权重规则进行计算，不直接写死具体组合。

### 7.3 探索棋盘规则
- **空间结构**: 探索棋盘为6格宽 × 4格高（共24个格子）
- **格子编号规则**: 
  - 格子编号从左上角第1个格子开始作为编号1，先向右编号（1, 2, 3, 4, 5, 6），再向下到下一行继续编号（7, 8, 9, 10, 11, 12），以此类推直到最右下方的格子编号为24
  - 编号公式：`格子编号 = (行号 - 1) × 6 + 列号`（行号和列号从1开始）
  - 格子编号用于战斗系统的攻击顺序判定（详见8.1战斗规则）
- **角色占用**: 每个角色占用1个格子
- **怪物生成**: 根据配置表设定的怪物类型和数量
- **垃圾生成**: 原始物资，需要通过角色特长天赋采集
- **基础产出**: 垃圾有默认基础产出
- **产出提升**: 通过角色技能、天赋、科技树提升
- **回合与体力规则**: 
  - 探索棋盘内不再进行大地图移动
  - 每进入探索点的1层探索棋盘，视为“探索1层”，消耗1个回合（30分钟），体力-1（由3.1回合运作流程统一结算）
  - 同一层内的棋盘行动（移动、采集、战斗）发生在同一回合内，不额外推进回合计数
- **探索进度规则**: 
  - 对于每个探索点，对应地图格子的 `explorationProgress` 由当前层数和最大层数计算：`explorationProgress = currentLayer / maxLayers * 100`（四舍五入）
  - 当 `currentLayer >= maxLayers` 时，探索进度视为100%，满足4.2中“探索进度达到100%”的条件，可将探索点转换为空地
- **垃圾产出处理规则**: 
  - **自动处理机制**：垃圾产出不再需要玩家手动点击采集，而是在战斗结束后自动处理
  - **处理顺序**：战斗结算完成后，按棋盘编号从小到大遍历所有有垃圾的格子，依次处理每个垃圾的产出
  - **产出判定流程**：
    1. 对每个垃圾格子，首先尝试触发"进阶产出机制"（检查 `GarbageConfig.进阶产出机制ID列表` 中配置的条件是否满足）
    2. 如果任一进阶产出机制条件满足，则使用 `GarbageConfig.进阶产出` 作为最终产出
    3. 如果所有进阶产出机制条件都不满足，则使用 `GarbageConfig.默认搜索产出` 作为最终产出
  - **产出应用**：所有垃圾的产出自动应用到探险队背包中，按照6.3资源分配规则进行分配
  - **负值产出处理**：当产出数量为负值时（如 `resource_food_-1`），从背包中减少对应资源；如果背包中没有该资源或数量不足，则不减少（不会扣到负数）
- **探索完成条件**: 
  - 只要队伍中还有至少1个角色存活（`currentHP > 0`），即判定完成了本层的探索，可以进入下一层
  - 玩家也可以主动选择退出当前层（返回地图界面）
  - 如果所有角色都死亡，则探索失败，强制返回地图界面
- **层数规则**: 
  - 每次进入探索点均从第1层开始
  - 完成当前层探索后自动进入下一层（层数+1，重新生成探索空间）
  - 达到配置的最大层数后，强制结束探索并返回地图界面
  - 玩家需手动选择下一个目标点继续探索
- **棋盘刷新规则**: 
  - **每次进入新的一层探索棋盘时，必须对所有单位进行随机位置刷新**：
    - 角色位置：从当前存活的探险队成员中，随机选择不重复的格子进行放置
    - 怪物位置：根据"棋盘出现内容"配置，按权重随机生成怪物并随机放置在剩余空格子上
    - 垃圾位置：根据"棋盘出现内容"配置，按权重随机生成垃圾并随机放置在剩余空格子上
  - 同一探索点的不同层之间，角色、怪物、垃圾的位置必须完全重新随机化，不能保留上一层的位置
  - 随机化算法应确保每次生成都有不同的布局，提升探索的多样性

### 7.4 探索数据结构
```csharp
ExplorationSpace {
    int width;                    // 宽度（6格）
    int height;                   // 高度（4格）
    GridCell[,] cells;            // 格子数组
    List<Explorer> explorers;     // 探险者列表
    List<Monster> monsters;       // 怪物列表
    List<Garbage> garbage;        // 垃圾列表
    ExplorationState state;       // 探索状态
    int currentLayer;            // 当前层数（从1开始）
    int maxLayers;                // 最大层数（从 ExplorationPointConfig 加载）
    string explorationPointId;    // 当前探索点ID
}
```

### 7.5 返回避难所机制
- **撤退触发**: 玩家可在任意回合选择直接"撤退"（无论是在大地图上还是在探索空间内）
- **避难所选择**: 
  - 点击撤退后，地图中将展示所有激活的"避难所"（已建造的避难所）
  - 玩家主动点击选择一个避难所作为返回目标
- **路径计算与确认**: 
  - 选择避难所后，系统自动计算并展示从当前位置到目标避难所的行进路径
  - 系统告知玩家需要的时间：走1个格子需要30分钟（也就是1回合）
  - 显示总回合数 = 路径格子数
  - 玩家点击"确定"则开始进入返回避难所的移动
- **返回移动规则**: 
  - 返回过程中，每回合在大地图上朝目标避难所移动1格（与正常探索移动相同）
  - 返回过程中，队伍状态为"返回中"（不可更换成员）
  - 返回过程中，如果路过的是"道路"类格子，格子上触发的事件还是会触发（如深夜时大概率遇到怪物）
  - 返回过程中，如果路过的是"探索点"类格子，则不会触发探索玩法，直接通过
- **物资携带**: 
  - 玩家可将所有探险队中角色背包内的物资带回避难所
  - 临时背包中的物品在返回过程中无法带回避难所（临时背包在进入下一回合时清空）
  - 建议玩家在撤退前将临时背包中的重要物品移入角色背包
- **到达避难所**: 
  - 到达目标避难所后，自动保存所有角色背包内的资源到避难所仓库
  - 所有避难所的仓库是同一个仓库（共享仓库系统）
  - 到达避难所后，队伍状态变为"在避难所"（可更换成员）

---

## 8. 战斗系统设计

### 8.1 战斗规则
- **战斗类型**: 战斗是回合内处理计算的类型，每个回合在满足触发条件时进行一次完整的战斗运算
- **战斗触发**: 
  - 探索棋盘内：当角色攻击范围内有怪物时触发战斗
    - **攻击范围定义**：角色的攻击范围默认为相邻格子（包括上下左右4个方向以及斜方向的左上、左下、右上、右下，总共8个方向，距离1格），可通过角色属性或科技树扩展
    - 每个回合开始时，系统检测所有角色的攻击范围内是否有怪物，如果有则触发战斗；战斗结算完成后，玩家再进行本回合内的其它棋盘行动
  - 返回路径：在深夜时大概率遇到怪物（大地图上的战斗）
- **探索棋盘格子编号规则**: 
  - 探索棋盘为6格宽 × 4格高（共24个格子）
  - 格子编号从左上角第1个格子开始作为编号1，先向右编号（1, 2, 3, 4, 5, 6），再向下到下一行继续编号（7, 8, 9, 10, 11, 12），以此类推直到最右下方的格子编号为24
  - 编号公式：`格子编号 = (行号 - 1) × 6 + 列号`（行号和列号从1开始）
- **攻击顺序与目标规则**: 
  - **第一阶段（角色攻击阶段）**：先由我方角色按照所在格子的编号由小到大的顺序进行攻击
    - 对于每个角色，按照其攻击范围内所有敌人的格子编号由小到大依次结算攻击，默认不限制本次攻击涉及的敌人数量（即可依次攻击范围内所有敌人）
  - **第二阶段（怪物攻击阶段）**：再由怪物按照所在格子的编号由小到大的顺序进行攻击
    - 对于每个怪物，按照其攻击范围内所有角色的格子编号由小到大依次结算攻击，同样默认不限制目标数量
  - 如果同一格子内有多个角色或多个怪物，则在该格内按加入战斗的顺序或ID排序
- **伤害计算**: 攻击力直接扣除血量（后续如引入防御等机制，再在此扩展）
- **先手规则**: 角色优先攻击怪物（角色攻击阶段在怪物攻击阶段之前）

### 8.2 战斗流程
```
检测战斗触发条件（角色攻击范围内是否有怪物）
    ↓
触发战斗（回合内战斗计算开始）
    ↓
第一阶段：角色攻击阶段
    ├─ 按探索棋盘格子编号由小到大遍历
    ├─ 对每个格子中的角色，依次对其攻击范围内所有敌人（按格子编号由小到大排序）进行攻击
    └─ 如果怪物死亡，从战斗列表中移除
    ↓
第二阶段：怪物攻击阶段
    ├─ 按探索棋盘格子编号由小到大遍历
    ├─ 对每个格子中的怪物，依次对其攻击范围内所有角色（按格子编号由小到大排序）进行攻击
    └─ 如果角色血量降至0，进入濒死状态
    ↓
判断战斗结果
    ├─ 如果所有怪物死亡：角色胜利，获得战利品，继续在本层探索棋盘中行动
    ├─ 如果所有角色死亡：探索失败，强制返回地图界面
    └─ 如果双方都有存活单位：本回合战斗计算结束，下一回合开始时如仍满足触发条件，将再次进行战斗计算
    ↓
战斗后垃圾产出处理（详见8.3战斗后垃圾产出规则）
    ↓
战斗结束（本回合战斗计算完成）
```

### 8.3 战斗后垃圾产出规则
- **触发时机**：每个回合战斗结算完成后，自动触发垃圾产出处理
- **处理顺序**：按棋盘编号从小到大遍历所有有垃圾的格子（`ExplorationBoardCell.garbageId` 不为空的格子）
- **产出判定**：对每个垃圾格子：
  1. 读取该垃圾的配置（`GarbageConfig`）
  2. 检查是否满足"进阶产出机制"条件（详见9.2资源收集规则中的进阶产出机制）
  3. 如果满足任一进阶产出机制，使用 `GarbageConfig.进阶产出` 作为产出
  4. 如果不满足，使用 `GarbageConfig.默认搜索产出` 作为产出
- **产出应用**：
  - 所有垃圾的产出自动合并后，按照6.3资源分配规则分配到探险队成员背包中
  - 支持负值产出：当产出数量为负值时（如 `resource_food_-1`），从背包中减少对应资源
  - 负值处理规则：如果背包中没有该资源或数量不足，则不减少（不会扣到负数）
- **玩家操作**：垃圾产出处理完全自动化，玩家无需手动点击采集按钮

### 8.4 濒死处理
- **触发条件**: 角色血量 = 0
- **处理时间**: 回合结束前
- **恢复方式**: 消耗背包中的补血道具
- **失败后果**: 回合结束时未治疗则角色死亡

### 8.5 角色死亡处理
- **触发条件**: 角色在回合结束时处于濒死状态且未治疗
- **死亡位置**: 角色死亡时所在的格子（探索空间内或地图上）
- **数据存储**: 
  - 角色死亡时，将该角色背包中的所有物品转移到死亡格子的 `GridCell.droppedItems` 字段中
  - 记录死亡时的回合数到 `GridCell.deathRound` 字段
  - 记录死亡角色的ID到 `GridCell.deadExplorerId` 字段
- **背包物品处理**: 
  - 死亡的该角色的背包中的物品将落在死亡的格子上（存储在 `GridCell.droppedItems` 中）
  - 玩家在96个回合内还能查看和拿走背包中的物品（96回合 = 48小时 = 2天游戏时间）
  - **过期判断**：从角色死亡时的回合数开始计算，无论队伍是否在场。当 `当前回合数 - GridCell.deathRound >= 96` 时，该格子的 `droppedItems` 将被清空（物品消失）
  - 其他角色（包括同队伍成员或其他探险队）可以前往死亡格子拾取物品
- **物品拾取规则**: 
  - 队伍需要移动到死亡格子才能拾取物品
  - 拾取时打开物品列表界面（显示 `GridCell.droppedItems`），玩家可选择拾取哪些物品
  - 拾取的物品按照6.3资源分配规则放入角色背包
  - 如果角色背包已满，放入临时背包（临时背包会自动解锁）
- **资源处理**: 
  - 角色死亡时该角色背包内的资源将全部保留（保留在死亡格子上，遵循96回合规则）
  - 资源拾取规则与物品相同，可在96回合内由其他角色拾取
- **角色损失**: 
  - 角色的其他部分（角色本身、天赋、科技树进度等）将彻底损失
  - 角色从玩家列表中移除（或标记为已死亡）
  - 角色无法复活，需要重新解锁或获取

---

## 9. 资源系统设计

### 9.1 资源类型
- **基础资源**: 食物、水、材料等
- **特殊资源**: 科技点、专属道具等
- **垃圾资源**: 探索棋盘中的原始物资

### 9.2 资源收集规则
- **基础产出**: 垃圾有默认基础产出
- **产出提升**: 
  - 角色天赋加成
  - 科技树加成
  - 技能效果
- **体力影响**: 体力为0时，只能获得基础产出
- **资源分配**: 
  - 采集获得的资源按照队伍成员排序（第1名、第2名、第3名）优先分配
  - 优先放入第1名队员的背包，依次类推（详见6.3背包使用规则）
  - 玩家可随时手动调整资源在不同角色背包间的存放位置
- **堆叠处理**: 
  - 资源放入背包时，优先堆叠到已有相同资源的格子上（不超过堆叠最大数量）
  - 如果已有格子堆叠已满，则占用新格子
  - 如果所有角色背包都没有空格子，则放入临时背包
  - 临时背包在进入下一回合时清空，玩家需在回合结束前整理背包（详见6.3背包使用规则）
- **负值产出处理**: 
  - 当垃圾的默认产出或进阶产出中包含负值数量时（如 `resource_food_-1`），系统会从背包中减少对应资源
  - 减少规则：优先从已有堆叠中减少，如果数量不足则只减少到0（不会扣到负数）
  - 如果背包中完全没有该资源，则不进行任何操作（不减少）
  - 负值产出不会占用背包容量，只进行减少操作

### 9.3 资源保存
- **保存时机**: 返回避难所后
- **保存方式**: 自动保存到避难所仓库
- **仓库系统**: 所有避难所的仓库是同一个仓库（共享仓库系统），无论从哪个避难所返回，资源都保存在同一个仓库中
- **资源转移流程**: 
  - 到达避难所后，弹出资源转移界面
  - 系统自动将队伍中所有角色背包内的资源转移到避难所仓库
  - 玩家可选择"全部转移"或"部分转移"（选择哪些资源转移）
  - 转移操作不消耗回合
- **探索中**: 资源暂存在各角色的独立背包中（详见6.3背包使用规则）
- **返回过程中**: 资源仍保留在各角色的独立背包中，直到到达避难所后转移
- **角色死亡情况**: 角色死亡时，该角色背包内的资源将落在死亡格子上，遵循96回合拾取规则（详见8.4角色死亡处理）

### 9.4 资源使用
- **避难所扩建**: 消耗资源
- **角色强化**: 消耗特定道具，对单个角色的属性或技能效果进行一次性提升（如最大体力上限+2）
- **科技树解锁**: 消耗科技点或专属道具
- **天赋升级**: 消耗专属道具

---

## 10. 避难所系统设计

### 10.1 避难所功能
- **角色管理**: 选择探险者组成队伍
- **资源存储**: 保存收集的资源
- **建设升级**: 扩建避难所设施
- **角色强化**: 通过消耗特定道具对角色进行一次性强化（例如提升最大体力上限）
- **科技研究**: 解锁科技树

### 10.2 建设系统
- **建设条件**: 
  - 格子类型为"空地"
  - 满足资源要求
  - 满足其他条件（如科技解锁）
- **建设类型**: 
  - 新避难所
  - 资源采集站
  - 防御设施
  - 其他建筑（策划配置）

> 可建造的设施类型必须来自配置表中定义的白名单（详见 ShelterLevelConfig），禁止在代码中硬编码“当前等级可以建造哪些设施”。

### 10.3 避难所等级与解锁逻辑

- **初始等级**  
  - 首次建造完成避难所时，避难所等级设为 **1级**。
- **等级含义**  
  - 每一级避难所对应一组配置：  
    - 该等级达成时默认解锁/建成的设施列表；  
    - 从该等级开始允许建造的设施类型列表；  
    - （可选）该等级下避难所可容纳的设施数量上限等。
- **解锁逻辑**  
  - 当避难所从“无 → 1级”或从 `N → N+1` 升级时：  
    - 根据 `ShelterLevelConfig` 中对应等级的配置，自动解锁/建成配置中的设施；  
    - 更新当前等级下允许建造的设施白名单。
- **数据来源**  
  - 所有与避难所等级相关的解锁规则，均由配置表 `ShelterLevelConfig` 控制，不允许在代码中写死某等级解锁哪些设施。

---

## 11. 配置表系统设计

在本项目中，地图（格子类型与分布）、探险者（属性与状态）、探索点（可生成的怪物与垃圾）、避难所等级与设施解锁等**核心游戏数据全部采用配置驱动**的方式进行管理。  
代码负责解析和使用配置数据，但不直接硬编码具体数值、坐标或解锁关系。

### 11.1 配置表清单
1. **角色配置表 (ExplorerConfig)**
   - 角色基础属性（最大/初始血量与体力、攻击力等）
   - 初始背包格子数量（inventoryCapacity，用于决定角色背包可用格子总数）
   - 初始天赋ID列表（initialTalentIds，对应 `TalentConfig.talentId`）
   - 初始科技树解锁项
   - 末日前身份标签

2. **科技树配置表 (TechTreeConfig)**
   - 科技项ID
   - 科技名称
   - 所属分支（体魄/智力/谋略）
   - 解锁条件
   - 效果描述

3. **怪物配置表 (MonsterConfig)**
   - 怪物ID
   - 怪物名称
   - 血量、攻击力
   - 出现时间段
   - 出现概率

4. **地图配置表 (MapConfig)**
   - 格子类型
   - 格子坐标
   - 初始状态
   - 资源生成规则

5. **探索点配置表 (ExplorationPointConfig)**
   - 探索点ID
   - **注意**：探索点的位置坐标不在此表配置，而是由 `MapConfig` 中格子类型为"探索点"的格子通过 `资源生成规则ID` 字段关联决定
   - 最大层数 (maxLayers)：该探索点一次进入可探索的最大层数，达到后强制结束探索
   - 探索难度
   - 棋盘出现内容：配置该探索点在探索棋盘上可出现的单位（怪物/垃圾等）及其权重，格式为若干条 `出现类型_具体ID_出现权重值` 组成的列表（以竖线 `|` 分隔）

6. **资源配置表 (ResourceConfig)**
   - 资源ID
   - 资源名称
   - 基础产出
   - 稀有度
   - 堆叠最大数量 (maxStackSize)：该资源在背包中1个格子上最多可以堆叠的数量，超过此数量需占用新格子

7. **道具配置表 (ItemConfig)**
   - 道具ID
   - 道具名称
   - 道具类型
   - 使用效果
   - 堆叠最大数量 (maxStackSize)：该物品在背包中1个格子上最多可以堆叠的数量，超过此数量需占用新格子

8. **避难所等级配置表 (ShelterLevelConfig)**
   - 等级 (level)
   - 默认解锁设施列表 (autoUnlockedFacilities)：避难所达到该等级时自动解锁/建成的设施 ID 列表
   - 可建造设施列表 (buildableFacilities)：从该等级开始允许建造的设施 ID/类型列表
   - （可选）最大设施数量 (maxFacilitySlots)
   - （可选）升级前置条件 (requirements)：升级到该等级所需资源或前置条件

9. **技能配置表 (SkillConfig)**
   - 技能ID (skillId)：唯一标识一个技能，同时作为代码侧技能效果注册表中的键值
   - 名称文本Key (nameKey)：用于前端显示技能名称
   - 描述文本Key (descKey)：用于前端显示技能描述，可在文案中使用 `{icon:图标ID}` 占位符插入图标
   - 效果类型 (effectType)：用于**归类**该技能的大致类型，例如 `BattleBuff`、`ExploreBuff`、`ExtraDrop` 等（便于策划筛选与检索）
   - 效果参数 (effectParams)：以字符串形式存储的参数，由代码解析，例如 `shieldRate=0.2;durationRounds=3` 或 JSON 字符串；
     - 代码侧会根据 `skillId` 在技能效果注册表中找到对应的处理函数，并将解析后的参数对象传入
   - 触发时机 (triggerTiming)：该技能效果被结算的时机，例如：`OnBattleStart`、`OnAttack`、`OnGarbageSearched`、`OnEnterExplorationBoard` 等
   - 作用目标 (targetType)：技能生效的目标范围，例如：`Self`（自身）、`CurrentExplorer`（当前执行动作的角色）、`Team`（当前小队全体）等
   - （可选）消耗道具ID (requiredItemId)：学习或激活该技能需要消耗的道具ID（对应 `ItemConfig`），用于实现“吞卡/消耗品解锁技能”等玩法

10. **天赋配置表 (TalentConfig)**
    - 天赋ID (talentId)：唯一标识一个天赋，同时作为代码侧天赋效果注册表中的键值
    - 名称文本Key (nameKey)：用于前端显示天赋名称
    - 描述文本Key (descKey)：用于前端显示天赋描述，可在文案中使用 `{icon:图标ID}` 占位符插入图标
    - 效果类型 (effectType)：用于归类该天赋的大致类型，例如 `PermanentBuff`、`BattleBuff`、`ExploreBuff` 等
    - 效果参数 (effectParams)：以字符串形式存储的参数，由代码解析并传入对应的天赋效果处理函数
    - 解锁条件类型 (unlockConditionType)：用于区分不同的解锁逻辑，例如 `TechReached`（达成某科技）、`ShelterLevelReached`（避难所等级达到X）、`StoryFlag`（剧情标记）等
    - 解锁条件参数 (unlockConditionParams)：以字符串形式存储的解锁条件参数，例如 `TechId=tech_engineer;Level>=2`
    - 是否可叠加 (stackable)：true/false，用于标记该天赋是否可以被多次获得并叠加效果
    - （可选）最大叠加层数 (maxStacks)：当 `stackable = true` 时，限制该天赋最多可叠加多少层（为空时视为无限）

11. **垃圾配置表 (GarbageConfig)**
    - 垃圾ID (garbageId)
    - 名称文本Key (nameKey)
    - 描述文本Key (descKey)：支持在文案中使用 `{icon:图标ID}` 形式的占位符插入图标，用于直观展示进阶产出机制
    - 默认搜索产出 (defaultSearchOutput)：当该垃圾被正常搜刮时的基础产出，格式为 `资源ID_数量` 列表，以竖线 `|` 分隔，例如 `resource_metal_1|resource_food_2`
    - 垃圾类型列表 (garbageTypes)：该垃圾所属的类型标签列表，用于与角色技能触发条件匹配，多个类型以竖线 `|` 分隔，例如 `废金属|可燃物`
    - 进阶产出机制ID列表 (advancedOutputConditionIds)：引用进阶产出机制配置表 `AdvancedOutputConditionConfig` 中的 conditionId，多个值以竖线 `|` 分隔
    - 进阶产出 (advancedOutput)：当满足任一进阶产出机制时，用于替代默认搜索产出的高级产出配置，格式同 `defaultSearchOutput`，例如 `resource_metal_5|resource_rare_chip_1`

12. **进阶产出机制配置表 (AdvancedOutputConditionConfig)**
    - 进阶产出机制ID (conditionId)
    - 名称文本Key (nameKey)
    - 描述文本Key (descKey)：用于向玩家解释该机制的触发条件与效果，同样支持 `{icon:图标ID}` 占位符
    - 适用垃圾类型列表 (targetGarbageTypes)：该机制适用的垃圾类型标签列表，多个类型以竖线 `|` 分隔；当某个垃圾的 `garbageTypes` 与该列表有交集时，该机制有资格被应用
    - 触发条件类型 (conditionType)：用于代码区分不同类型的触发逻辑，如 `ExplorerTagCount`（需要特定标签的角色数量）、`Difficulty`（探索点难度）、`Mixed`（复杂组合）等
    - 触发条件参数 (conditionParams)：以字符串形式存储的条件参数（可采用简单的 `Key=Value;Key2=Value2` 形式或JSON字符串），由游戏逻辑解析和执行

### 11.2 配置表格式建议
- **格式**: JSON 或 ScriptableObject（Unity推荐）
- **位置**: `Assets/Config/`
- **加载方式**: 运行时加载或序列化

---

## 12. 系统架构设计

### 12.1 核心系统模块
```
GameManager (游戏管理器)
    ├── TimeSystem (时间系统)
    ├── RoundSystem (回合系统)
    ├── MapSystem (地图系统)
    ├── ExplorerSystem (探险者系统)
    ├── ExpeditionSystem (探险队系统)
    ├── ExplorationSystem (探索系统)
    ├── BattleSystem (战斗系统)
    ├── ResourceSystem (资源系统)
    ├── ShelterSystem (避难所系统)
    └── ConfigSystem (配置表系统)
```

### 12.2 数据层设计
- **GameData**: 游戏存档数据
- **ConfigData**: 配置表数据
- **RuntimeData**: 运行时临时数据

### 12.3 UI层设计
- **MainUI**: 主界面
- **MapUI**: 地图界面
- **ExplorerUI**: 探险者管理界面
- **ExpeditionUI**: 探险队界面
- **ExplorationUI**: 探索界面
- **BattleUI**: 战斗界面
- **ShelterUI**: 避难所界面
- **TechTreeUI**: 科技树界面
- **InventoryUI**: 背包界面
  - **功能入口**：在探索界面底部提供"背包"按钮，点击后打开背包面板
  - **显示内容**：显示当前探险队所有成员的背包状态
  - **信息展示**：每个队员显示头像、名称、HP状态、背包格子列表
  - **格子显示**：每个背包格子显示物品图标、名称、数量；空格子显示为空
  - **交互方式**：背包界面为只读查看模式（当前版本），玩家可查看但不能直接操作（物品移动等功能待后续实现）

#### 12.3.1 输入与交互规范
- **输入设备**  
  - Demo 阶段主要支持键鼠操作（鼠标点击/拖拽 + 键盘快捷键）；手柄和触摸支持可在后续版本扩展。
- **基础交互规则**  
  - 所有可点击 UI 元素必须具备 Hover（悬停）与 Pressed（按下）两种视觉反馈状态。  
  - 所有关键破坏性操作（例如删除存档、退出到主菜单、放弃当前探索）必须有二次确认对话框。  
  - 统一的返回/取消逻辑：ESC 键或右键点击应尽可能返回上一级界面或关闭当前弹窗。
- **布局与分层**  
  - UI 需根据场景分层管理（主界面层、地图层、战斗层、弹窗层等），避免互相遮挡和输入冲突。

#### 12.3.2 分辨率与适配
- **分辨率要求**  
  - 推荐分辨率：1920×1080（16:9），其他宽高比需要保证 UI 不错位、不裁切。  
  - 最低支持分辨率由美术与技术共同评估后在实现阶段细化。
- **字体与可读性**  
  - 重要文本（数值、按钮文字）需保证在最低分辨率下仍具备可读性，不允许过小字体。  
  - 文本长度变化（特别是未来多语言）不应导致布局破坏，应预留足够容错空间。

### 12.4 性能与规模边界

- **地图与探索棋盘规模**  
  - 地图尺寸上限建议控制在 100×100 格以内，以便保证性能和内容生产成本。  
  - 单个探索棋盘固定为 6×4（24 个格子），后续如需扩展需重新评估性能与可玩性。
- **单位数量上限（Demo 阶段）**  
  - 单个探索空间内的怪物数量、垃圾数量、资源堆数量应设定合理上限（例如：怪物不超过 10 个，垃圾不超过 20 堆），具体数值由配置表与实际性能测试共同确定。  
  - 同一时刻仅允许一支探险队在外探索（单队伍模式），以降低系统复杂度。
- **性能目标（PC Demo）**  
  - 目标平台为 PC，窗口/全屏模式下期望维持 60 FPS。  
  - 在“推荐规模”（例如 50×50 地图 + 若干探索点 + 一支满员队伍）下，帧率不应出现明显跌落。
- **优化优先级**  
  - 地图加载与寻路逻辑优先保证性能；  
  - 探索空间更新（包括怪物 AI 与碰撞检测）其次；  
  - UI 更新与特效需要在不影响主循环的前提下实现。

---

## 13. 数据持久化设计

### 13.1 存档数据结构
```csharp
SaveData {
    int version;                 // 存档版本号，用于兼容性判断和迁移
    int currentDay;              // 当前天数
    int currentRound;            // 当前回合数
    List<ExplorerData> explorers; // 探险者数据
    MapData mapData;             // 地图数据
    ShelterData shelterData;     // 避难所数据
    ResourceData resourceData;   // 资源数据
    ExpeditionData expeditionData; // 探险队数据
}
```

### 13.2 存档时机
- **自动存档**: 在每个回合完全结束，并完成所有结算（包括时间推进、体力扣除、临时背包清空等）后自动保存一次
- **手动存档**: 仅允许在回合结束状态（未开始下一回合前）触发，避免半回合状态存档
- **读取规则**: 重新读取存档时，总是从“新回合开始”的状态恢复，玩家只能继续点击“下一回合”推进游戏

### 13.3 存档版本与兼容性

- **版本号含义**  
  - 存档中的 `version` 字段用于标识存档结构与数据语义的版本。  
  - 建议采用 `major.minor.patch` 语义（实现时可用整型或字符串表示），其中：  
    - `major`：不兼容结构变更（如字段删除、语义改变）时递增；  
    - `minor/patch`：兼容性变更（新增字段、修复逻辑）时递增。
- **破坏性变更策略（Demo 阶段）**  
  - 当检测到存档版本与当前游戏版本不兼容（例如 `major` 版本不一致）时，Demo 阶段可以采用“拒绝加载并提示需要清档”的简单策略。  
  - 未来若需要长期兼容，将在后续迭代中引入 `SaveMigration` 模块，对旧版本存档进行迁移。
- **配置与存档的关系**  
  - 配置表结构（如增加字段）应尽量保持向后兼容；删除字段或改变字段语义时，应视为潜在破坏性变更，在 SPEC 文档中记录并结合存档版本策略一并考虑。  
  - 若某次配置调整会导致旧存档中的 ID 不再存在或语义发生重大变化，需在 SPEC 的“待确认问题”或变更记录区域中注明影响与处理方式。

---

## 14. 实现优先级

### 14.1 第一阶段（核心系统）
1. [ ] 时间系统和回合系统
2. [ ] 地图系统（基础格子）
3. [ ] 探险者系统（基础属性）
4. [ ] 探险队系统（选择和管理）
5. [ ] 基础探索流程

### 14.2 第二阶段（玩法系统）
1. [ ] 探索空间生成
2. [ ] 战斗系统
3. [ ] 资源收集系统
4. [ ] 避难所基础功能

### 14.3 第三阶段（进阶系统）
1. [ ] 科技树系统
2. [ ] 天赋系统
3. [ ] 建设系统
4. [ ] 配置表系统

### 14.4 第四阶段（优化和扩展）
1. [ ] UI优化
2. [ ] 平衡性调整
3. [ ] 内容扩展
4. [ ] 性能优化

---

## 15. 技术实现建议

### 15.1 Unity架构建议
- **MVC/MVP模式**: 分离逻辑和视图
- **事件系统**: 使用UnityEvent或C#事件解耦
- **对象池**: 怪物、UI元素等使用对象池
- **单例模式**: 管理器类使用单例（谨慎使用）

### 15.2 性能优化
- **地图分块加载**: 大地图分块加载
- **资源异步加载**: 配置表和资源异步加载
- **UI优化**: 使用UI Canvas分组，减少重绘
- **对象池**: 频繁创建销毁的对象使用对象池

### 15.3 代码规范
- **命名规范**: 使用清晰的命名（PascalCase类名，camelCase变量名）
- **注释**: 关键逻辑添加注释
- **模块化**: 功能模块化，便于维护和扩展

### 15.4 日志与调试规则
- **日志等级与分类**  
  - 至少支持 Info / Warning / Error / Debug 四种日志等级。  
  - 建议使用统一的日志封装（例如 `LogSystem`），禁止在核心系统中随意使用 `Debug.Log` 分散输出。
- **日志前缀约定**  
  - 不同系统的日志应使用统一前缀，便于过滤和追踪，例如：  
    - `[TimeSystem]` 时间系统  
    - `[RoundSystem]` 回合系统  
    - `[ExplorationSystem]` 探索系统  
    - `[BattleSystem]` 战斗系统  
    - `[ResourceSystem]` 资源系统  
    - `[ShelterSystem]` 避难所系统  
    - `[SaveSystem]` 存档系统
- **关键打点要求**  
  - 以下关键事件必须有至少一条 Info 级别日志：  
    - 回合开始与结束（包含当前天数、回合数、时间段）；  
    - 探索开始与结束（包含探索点 ID、队伍成员信息）；  
    - 战斗开始与结束（包含双方单位概要与结果）；  
    - 资源结算（采集结果、消耗情况）；  
    - 存档读取与写入（包含存档版本号、主要数据摘要）。  
  - 发生 Error 级别问题（如配置缺失、数据不一致、异常崩溃前）必须输出详细错误日志。
- **调试模式**  
  - 在 Unity Editor 或开发构建中，可以开启 Debug 级别日志，以便调试；在正式发布版本中应关闭 Debug 级别日志，仅保留必要的 Info/Warning/Error。  
  - 如后续引入调试控制台/开发者工具，应在 SPEC 中补充相应规则。

---

## 16. 测试阶段特殊规则

### 16.1 角色解锁
- **默认状态**: 所有角色默认解锁
- **配置方式**: 后续通过配置表编辑属性

### 16.2 调试功能
- **时间加速**: 可添加时间加速功能（测试用）
- **资源修改**: 可添加资源修改功能（测试用）
- **状态重置**: 可添加状态重置功能（测试用）

### 16.3 系统验收标准（Demo 阶段）
- **时间与回合系统**  
  - 在多天、多时间段连续推进的情况下（包括白天/傍晚/深夜切换），时间与回合计数必须保持一致，不出现跳变或逻辑卡死。  
  - 日志中能够清晰追踪每个回合的开始、结束与时间段变化。
- **地图与探索系统**  
  - 玩家可以稳定完成一次完整的探索闭环：选择目标点 → 出发 → 到达 → 探索与战斗/收集 → 返回避难所 → 资源正确结算。  
  - 地图上各类格子（避难所、道路、探索点、空地）在视觉与交互上均符合设计。
- **战斗系统**  
  - 常见怪物与队伍组合下，战斗流程必须可重复稳定执行，不出现无限回合、战斗无法结束或数值异常。  
  - 胜负判定与濒死/死亡处理符合 SPEC 约定。
- **资源与存档系统**  
  - 资源的获得与消耗在日志与界面上保持一致，不出现“凭空多出/消失”的情况。  
  - 在关键节点（返回避难所、手动存档）进行存读档，不会导致数据结构损坏或核心数据丢失。
- **避难所与建设系统**  
  - 首次建造避难所能正确设置为 1 级，并按 `ShelterLevelConfig` 解锁/允许建造对应设施。  
  - 不同等级下可建造设施的白名单行为正确，不能建造未解锁的设施。

---

## 17. 待确认问题

### 17.1 设计细节
1. 探索空间中的移动规则（回合制还是实时？）
2. 战斗系统的详细规则（技能、装备等）
3. 科技树的具体科技项和效果
4. 建设系统的具体建筑类型和效果
5. 资源的具体类型和用途

### 17.2 技术细节
1. 地图大小和复杂度
2. 存档格式（JSON/Binary）
3. 配置表格式（JSON/ScriptableObject/Excel）
4. 网络功能需求（单机/联机）

---

## 18. 后续扩展方向

### 18.1 玩法扩展
- 卡牌构建系统（如需求中提到的）
- 更多角色和怪物类型
- 更多探索点类型
- 天气系统
- 事件系统

### 18.2 系统扩展
- 成就系统
- 任务系统
- 排行榜系统
- 多周目系统

---

## 19. 国际化与文本管理

### 19.1 总体原则
- 所有对玩家可见的文本（UI 文案、角色名称、资源名称与描述、技能与天赋描述、关卡与探索点名称等），都应通过统一的文本管理系统提供，不应在代码中直接硬编码具体字符串。  
- 文本采用 Key-Value 形式管理，其中 Key 在配置表与代码中引用，实际文案则由多语言文本表决定。

### 19.2 文本 Key 规范
- 文本 Key 建议采用分层命名方式，例如：  
  - `ui.main.start_button`、`ui.map.shelter_name`  
  - `explorer.alice.name`、`explorer.alice.desc`  
  - `resource.metal.name`、`resource.metal.desc`  
  - `stage.abandoned_factory_1.name`、`stage.abandoned_factory_1.desc`
- 配置表中不直接存中文文案，而是存对应的文本 Key（如 `nameKey`、`descKey`），运行时通过 `LanguageManager` 或类似模块根据当前语言加载实际文案。

### 19.3 语言与运行时切换
- **语言支持策略（Demo 阶段）**  
  - 当前仅强制支持简体中文（`zh-CN`），但所有文本结构设计需预留英文（`en-US`）等多语言扩展空间。  
  - 文本表格式需支持为同一 Key 提供多种语言版本（例如每条记录包含 `key`, `zhCN`, `enUS` 等字段）。
- **运行时语言切换**  
  - 提供集中管理当前语言状态的模块（如 `LanguageManager`），负责：  
    - 记录当前语言枚举值；  
    - 根据语言与 Key 返回对应字符串；  
    - 触发 UI 文本刷新（例如通过观察者模式或事件系统）。
  - 当前语言的选择可保存在设置或存档中，以便下次启动时恢复。

### 19.4 与配置表的关系
- `ExplorerConfig`、`ResourceConfig`、`ItemConfig`、`ExplorationPointConfig` 等配置表中涉及展示给玩家的名称与描述时：  
  - 应使用 `nameKey`/`descKey` 字段引用文本 Key，而不是直接写死文案。  
  - 多语言扩展时，只需要在文本表中为这些 Key 填入对应语言的内容，无需修改配置表结构。

---

## 附录

### A. 术语表
- **回合**: 30分钟的游戏时间单位
- **格子**: 地图上的最小单位
- **探索点**: 可进行探索的格子类型
- **垃圾**: 探索棋盘中的原始物资
- **科技点**: 解锁科技树的资源
- **专属道具**: 用于升级天赋或解锁科技的道具

### B. 参考文档
- Unity官方文档
- 游戏设计文档（待补充）
- 配置表模板（待创建）

---

## 20. 开发变更记录

### 2024-12-10 变更记录

#### 功能新增与规则明确

1. **战斗后自动垃圾产出机制**（8.3节）
   - 战斗结算完成后，按棋盘编号从小到大自动处理所有垃圾格子
   - 先尝试触发"进阶产出机制"，未触发则使用"默认搜索产出"
   - 产出自动应用到探险队背包，无需玩家手动操作

2. **负值产出处理规则**（9.2节）
   - 支持负值产出（如 `resource_food_-1`），从背包中减少对应资源
   - 如果背包中没有该资源或数量不足，则不减少（不会扣到负数）

3. **背包界面功能**（12.3节）
   - 在探索界面底部添加"背包"按钮
   - 点击后打开背包面板，显示所有队员的背包内容
   - 支持查看每个队员的背包状态（当前版本为只读）

4. **探索棋盘刷新规则**（7.3节）
   - 每次进入新的一层探索棋盘时，必须对所有单位进行随机位置刷新
   - 角色、怪物、垃圾的位置必须完全重新随机化，不能保留上一层的位置

#### BUG修复与规则修正

1. **探索点位置配置修正**（11.1.5节）
   - 明确探索点的位置坐标由 `MapConfig` 决定，而非 `ExplorationPointConfig` 中的位置字段
   - 探索点通过 `MapConfig.资源生成规则ID` 字段与探索点ID关联

2. **探险队位置持久化规则**（6.2节）
   - 探险队在大地图上的位置在整个探索过程中持续保持
   - 从当前位置出发（而非总是从避难所出发）
   - 时间连续，回合数不会重置
   - 成员锁定，在外探索时不可更换

3. **地图坐标系统说明**（4.1节）
   - 明确UI渲染时X轴为垂直方向（行），Y轴为水平方向（列）
   - 明确寻路规则和格子可通行性

4. **时间段划分修正**（2.2节）
   - 更正时间段的具体回合范围
   - 明确UI颜色区分规则（白天白色、傍晚橙色、深夜紫色）

5. **配置表格式统一**（11.1.5节）
   - `ExplorationPointConfig` 中的"棋盘出现内容"字段统一为单一字段，支持字符串和数组两种格式
   - 怪物和垃圾的生成规则合并到同一个配置字段中

6. **多语言系统实现**（19节）
   - 实现了多语言文本管理系统（`LanguageManager`）
   - 配置表使用 `nameKey`/`descKey` 引用文本Key
   - 支持通过 `LocalizationConfig` CSV模板管理多语言文案

#### 代码架构调整

1. **移除手动采集逻辑**
   - 移除了探索棋盘上的"采集"按钮
   - 垃圾改为战斗后自动处理，提升游戏流畅度

2. **战斗系统扩展**
   - 新增 `processGarbageAfterBattle` 函数，处理战斗后的垃圾产出
   - 战斗流程中集成垃圾产出处理步骤

3. **资源分配系统扩展**
   - 新增 `removeFromExplorerInventory` 函数，支持负值产出处理
   - `distributeLootToExplorers` 函数支持负值处理逻辑

---

## 21. 任务系统设计

### 21.1 任务系统概述

任务系统是引导玩家游戏进程、提供明确目标与奖励的核心系统。通过任务系统，玩家可以获得游戏指引，了解当前应该完成的目标，并获得相应的奖励。

任务系统与核心循环的关系：
- **准备阶段**：任务可能要求玩家选择特定角色或准备特定资源
- **探索阶段**：任务可能要求玩家探索特定地点或收集特定资源
- **战斗/收集阶段**：任务可能要求玩家击败特定怪物或收集特定物品
- **返回阶段**：任务可能要求玩家返回避难所
- **建设阶段**：任务可能要求玩家建设特定设施或升级避难所
- **回合推进**：任务触发条件可能在回合推进时检查

### 21.2 任务机制设计

#### 21.2.1 自动领取机制

- **触发条件类型**：
  - **回合数触发**：达到特定回合数时自动领取
  - **前置任务触发**：完成指定前置任务后自动领取
  - **资源触发**：拥有特定资源达到指定数量时自动领取
  - **探索触发**：完成特定探索点后自动领取
  - **战斗触发**：击败特定怪物达到指定数量后自动领取
  - **避难所等级触发**：避难所达到指定等级时自动领取

- **触发条件检查时机**：
  - 每回合开始时检查回合数触发条件
  - 资源变化时检查资源触发条件
  - 任务完成时检查前置任务触发条件
  - 探索完成时检查探索触发条件
  - 战斗结束时检查战斗触发条件
  - 避难所升级时检查避难所等级触发条件

- **自动领取规则**：
  - 满足触发条件时，任务自动从"未触发"状态转为"已领取"状态
  - 同一时间可以存在多个已领取的任务
  - 任务领取后立即开始追踪完成条件

#### 21.2.2 任务完成机制

- **完成条件类型**：
  - **收集资源**：收集指定资源达到目标数量（如：收集食物 10/20）
  - **击败怪物**：击败指定怪物达到目标数量（如：击败僵尸 5/10）
  - **探索完成**：完成指定探索点达到目标次数（如：探索医院 1/3）
  - **建设完成**：建设指定建筑达到目标数量（如：建设资源站 2/5）
  - **回合数达到**：游戏进行到指定回合数（如：存活 48/48 回合）

- **完成条件动态更新**：
  - 任务条件显示格式：`当前值/目标值`（如"收集食物 10/20"）
  - 当前值实时更新：
    - 资源收集类：监听所有角色的背包变化，统计指定资源的总数量
    - 击败怪物类：监听战斗结果，统计击败的指定怪物数量
    - 探索完成类：监听探索完成事件，统计完成的指定探索点次数
    - 建设完成类：监听建设完成事件，统计建设的指定建筑数量
    - 回合数类：监听回合推进事件，统计当前回合数

- **手动完成规则**：
  - 玩家需要手动点击"完成任务"按钮
  - 点击时检查完成条件是否满足
  - 如果满足，任务状态转为"已完成"
  - 如果未满足，显示提示信息

#### 21.2.3 奖励领取机制

- **奖励类型**：
  - **资源奖励**：奖励指定数量的资源（如：食物 10、金属 5）
  - **道具奖励**：奖励指定数量的道具（如：医疗包 2）
  - **经验奖励**：奖励经验值（如果有经验系统）

- **奖励发放规则**：
  - 任务完成后，玩家需要手动点击"领取奖励"按钮
  - 点击后，奖励自动发放到玩家库存：
    - 资源奖励：通过 `distributeLootToExplorers` 分配到角色背包
    - 道具奖励：通过 `distributeLootToExplorers` 分配到角色背包
    - 经验奖励：如果存在经验系统，则增加角色经验值
  - 奖励领取后，任务状态转为"已领取奖励"

#### 21.2.4 自动接取下一任务

- **任务链设计**：
  - 每个任务可以配置 `nextQuestId`，指向下一个任务
  - 当任务完成并领取奖励后，自动检查是否存在下一个任务
  - 如果存在，检查下一个任务的触发条件是否满足
  - 如果满足，自动领取下一个任务
  - 如果不满足，等待触发条件满足后再自动领取

- **任务序列规则**：
  - 任务链可以形成线性序列（任务1 → 任务2 → 任务3）
  - 也可以形成分支序列（任务1 → 任务2a 或 任务2b）
  - 分支任务需要分别配置不同的 `nextQuestId`

### 21.3 任务界面设计

#### 21.3.1 界面位置

- **位置**：界面右侧上方常驻显示
- **布局**：固定位置，不随地图滚动而移动
- **层级**：位于其他UI元素之上，但不遮挡核心操作区域

#### 21.3.2 界面内容

- **任务列表**：
  - 显示当前所有"已领取"状态的任务
  - 按优先级（priority）排序显示
  - 每个任务显示为一个任务卡片

- **任务卡片内容**：
  - **任务名称**：使用多语言Key显示任务名称
  - **任务描述**：使用多语言Key显示任务描述
  - **任务条件**：动态显示完成条件（格式：`当前值/目标值`）
    - 例如："收集食物 10/20"
    - 例如："击败僵尸 5/10"
  - **完成任务按钮**：
    - 当完成条件满足时，按钮可用（可点击）
    - 当完成条件未满足时，按钮禁用（灰色，不可点击）
    - 点击后检查条件，满足则完成任务
  - **领取奖励按钮**：
    - 仅在任务状态为"已完成"且未领取奖励时显示
    - 点击后发放奖励并更新任务状态

- **任务状态显示**：
  - 已完成的任务高亮显示（如：绿色边框或背景）
  - 可领取奖励的任务闪烁提示（可选）

#### 21.3.3 界面交互

- **实时更新**：
  - 任务条件实时更新（资源变化、战斗结果等触发更新）
  - 更新频率：每次相关事件发生时立即更新

- **折叠/展开**：
  - 任务列表可以折叠/展开（可选功能）
  - 折叠时只显示任务数量，展开时显示完整任务列表

- **任务详情**：
  - 点击任务卡片可以展开/折叠任务详情（可选功能）
  - 详情中显示完整的任务描述和奖励信息

### 21.4 任务数据结构

```csharp
// 伪代码结构
Quest {
    string questId;                    // 任务ID
    string nameKey;                    // 任务名称（多语言Key）
    string descKey;                    // 任务描述（多语言Key）
    QuestStatus status;                // 任务状态：未触发/已领取/已完成/已领取奖励
    QuestTriggerCondition triggerCondition;  // 触发条件
    QuestCompletionCondition completionCondition;  // 完成条件
    QuestReward reward;                // 奖励
    string nextQuestId;                // 下一个任务ID（任务链）
    int priority;                      // 优先级（用于排序显示）
}

QuestStatus {
    NotTriggered,      // 未触发
    Accepted,         // 已领取
    Completed,        // 已完成
    RewardClaimed     // 已领取奖励
}

QuestTriggerCondition {
    TriggerType type;                  // 触发类型：回合数、前置任务、资源等
    Dictionary<string, object> params; // 触发条件参数
}

TriggerType {
    RoundReached,     // 回合数达到
    QuestCompleted,   // 前置任务完成
    ResourceOwned,    // 拥有资源
    ExplorationCompleted, // 探索完成
    MonsterDefeated,  // 击败怪物
    ShelterLevelReached // 避难所等级达到
}

QuestCompletionCondition {
    ConditionType type;                // 条件类型：收集资源、击败怪物、探索完成等
    string targetId;                   // 目标ID（如资源ID、怪物ID）
    int targetValue;                   // 目标值
    int currentValue;                  // 当前值（动态更新）
}

ConditionType {
    CollectResource,  // 收集资源
    DefeatMonster,    // 击败怪物
    CompleteExploration, // 完成探索
    BuildFacility,    // 建设建筑
    ReachRound        // 达到回合数
}

QuestReward {
    List<ResourceReward> resources;   // 资源奖励
    List<ItemReward> items;           // 道具奖励
    int experience;                    // 经验奖励（如果有）
}

ResourceReward {
    string resourceId;                // 资源ID
    int quantity;                     // 数量
}

ItemReward {
    string itemId;                     // 道具ID
    int quantity;                      // 数量
}
```

### 21.5 任务配置表设计

#### 21.5.1 任务配置表 (QuestConfig)

任务配置表采用 JSON 格式，与现有配置表系统保持一致。

**字段定义**：

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| ID | string | 任务ID（唯一标识） | "quest_001" |
| 名称Key | string | 任务名称的多语言Key | "quest_001_name" |
| 描述Key | string | 任务描述的多语言Key | "quest_001_desc" |
| 触发条件类型 | string | 触发条件类型 | "RoundReached" |
| 触发条件参数 | string | 触发条件参数（JSON字符串或键值对） | "{\"round\": 10}" |
| 完成条件类型 | string | 完成条件类型 | "CollectResource" |
| 完成条件目标ID | string | 完成条件目标ID（资源ID、怪物ID等） | "resource_food" |
| 完成条件目标值 | number | 完成条件目标值 | 20 |
| 奖励资源列表 | string | 奖励资源列表（格式：资源ID_数量\|资源ID_数量） | "resource_food_10\|resource_metal_5" |
| 奖励道具列表 | string | 奖励道具列表（格式：道具ID_数量\|道具ID_数量） | "item_medkit_2" |
| 下一个任务ID | string | 任务链中的下一个任务ID（可选） | "quest_002" |
| 优先级 | number | 优先级（用于界面排序，数字越小优先级越高） | 1 |

**触发条件类型与参数格式**：

- **RoundReached**（回合数达到）：
  - 参数：`{"round": 10}` 表示第10回合时触发

- **QuestCompleted**（前置任务完成）：
  - 参数：`{"questId": "quest_001"}` 表示完成 quest_001 后触发

- **ResourceOwned**（拥有资源）：
  - 参数：`{"resourceId": "resource_food", "quantity": 5}` 表示拥有5个食物时触发

- **ExplorationCompleted**（探索完成）：
  - 参数：`{"explorationPointId": "point_hospital"}` 表示完成医院探索点后触发

- **MonsterDefeated**（击败怪物）：
  - 参数：`{"monsterId": "monster_zombie", "quantity": 3}` 表示击败3个僵尸后触发

- **ShelterLevelReached**（避难所等级达到）：
  - 参数：`{"level": 2}` 表示避难所达到2级时触发

**完成条件类型与目标ID**：

- **CollectResource**（收集资源）：
  - 目标ID：资源ID（如 "resource_food"）
  - 目标值：需要收集的数量

- **DefeatMonster**（击败怪物）：
  - 目标ID：怪物ID（如 "monster_zombie"）
  - 目标值：需要击败的数量

- **CompleteExploration**（完成探索）：
  - 目标ID：探索点ID（如 "point_hospital"）
  - 目标值：需要完成的次数

- **BuildFacility**（建设建筑）：
  - 目标ID：建筑类型ID（如 "facility_resource_station"）
  - 目标值：需要建设的数量

- **ReachRound**（达到回合数）：
  - 目标ID：固定为 "round"
  - 目标值：需要达到的回合数

### 21.6 任务系统实现要点

#### 21.6.1 任务状态管理

- **状态维护**：
  - 维护当前所有任务的状态（未触发、已领取、已完成、已领取奖励）
  - 使用 Map<string, Quest> 存储任务，key 为 questId

- **状态持久化**：
  - 任务状态需要保存到存档中
  - 存档时保存所有任务的状态和当前值
  - 读档时恢复任务状态和当前值

#### 21.6.2 条件检查系统

- **资源收集条件检查**：
  - 监听所有角色的背包变化事件
  - 统计指定资源在所有角色背包中的总数量
  - 更新对应任务的当前值

- **战斗条件检查**：
  - 监听战斗结果事件
  - 统计击败的指定怪物数量
  - 更新对应任务的当前值

- **探索条件检查**：
  - 监听探索完成事件
  - 统计完成的指定探索点次数
  - 更新对应任务的当前值

- **回合数条件检查**：
  - 监听回合推进事件
  - 更新回合数类任务的当前值

#### 21.6.3 任务界面组件

- **QuestPanel 组件**：
  - 使用 React 创建
  - 位置：界面右侧上方（固定定位）
  - 实时更新任务条件进度
  - 提供完成任务和领取奖励的交互按钮

### 21.7 任务系统与现有系统的集成

#### 21.7.1 与资源系统集成

- 监听资源变化事件（角色背包变化）
- 更新收集资源类任务的当前值
- 检查资源触发条件是否满足

#### 21.7.2 与战斗系统集成

- 监听战斗结果事件（怪物被击败）
- 更新击败怪物类任务的当前值
- 检查战斗触发条件是否满足

#### 21.7.3 与探索系统集成

- 监听探索完成事件（探索点完成）
- 更新探索完成类任务的当前值
- 检查探索触发条件是否满足

#### 21.7.4 与回合系统集成

- 在回合推进时检查回合数触发条件
- 更新回合数类任务的当前值
- 在回合开始时统一检查所有触发条件

#### 21.7.5 与存档系统集成

- 任务状态需要保存到存档中
- 包括：任务ID、任务状态、当前值
- 读档时恢复任务状态和进度

---

## 22. 章节系统设计

### 22.1 章节系统概述

章节系统是游戏进程管理的高层系统，用于组织游戏内容的分阶段推进。每个章节包含1到N张地图，玩家需要完成章节内的特定任务才能解锁下一章节。

章节系统与核心循环的关系：
- **章节层级**：章节 > 地图 > 探索点
- **章节解锁**：通过完成特定任务解锁新章节
- **剧情展示**：新章节解锁时显示剧情段落（包括第一章）
- **地图切换**：章节切换时加载对应章节的地图配置

### 22.2 章节机制设计

#### 22.2.1 章节结构

- **章节层级关系**：
  - 每个章节（Chapter）包含1到N张地图（Map）
  - 每张地图包含多个探索点、避难所等格子
  - 当前大地图是章节1的第一张地图

- **章节数据结构**：
  ```
  章节1
    ├─ 地图1（当前大地图）
    ├─ 地图2（待解锁）
    └─ 地图N
  章节2（待解锁）
    ├─ 地图1
    └─ 地图2
  ```

#### 22.2.2 章节解锁机制

- **解锁条件**：
  - 章节解锁与任务系统挂钩
  - 当玩家完成特定任务（章节结束任务）时，当前章节结束并解锁下一章节
  - 章节结束任务在任务配置中标记为 `章节结束任务`

- **解锁流程**：
  1. 玩家完成章节结束任务
  2. 系统检测到章节结束任务完成
  3. 当前章节标记为"已完成"
  4. 下一章节标记为"已解锁"
  5. 显示新章节的剧情段落
  6. 切换到新章节的第一张地图

#### 22.2.3 剧情展示机制

- **剧情触发时机**：
  - 新章节解锁时自动显示剧情段落
  - 包括第一章（游戏开始时显示）
  - 玩家可以点击"继续"按钮关闭剧情界面

- **剧情内容**：
  - 剧情文本使用多语言Key
  - 支持多段剧情文本（分段显示或一次性显示）
  - 剧情界面全屏或半屏遮罩显示

### 22.3 章节数据结构

```csharp
// 伪代码结构
Chapter {
    string chapterId;              // 章节ID
    string nameKey;                // 章节名称（多语言Key）
    string storyKey;               // 剧情文本Key（多语言Key，支持多段文本）
    int chapterNumber;             // 章节编号（1, 2, 3...）
    ChapterStatus status;          // 章节状态：未解锁/已解锁/进行中/已完成
    string[] mapIds;               // 该章节包含的地图ID列表
    string unlockQuestId;          // 解锁该章节所需的任务ID（章节结束任务）
    int priority;                  // 优先级（用于排序）
}

ChapterStatus {
    Locked,        // 未解锁
    Unlocked,      // 已解锁（可进入）
    InProgress,    // 进行中
    Completed      // 已完成
}

ChapterMap {
    string mapId;                  // 地图ID
    string chapterId;              // 所属章节ID
    int mapIndex;                  // 在该章节中的索引（1, 2, 3...）
    MapConfigEntry[] mapCells;     // 地图格子配置
}
```

### 22.4 章节配置表设计

#### 22.4.1 章节配置表 (ChapterConfig)

**字段定义**：

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| ID | string | 章节ID（唯一标识） | "chapter_001" |
| 名称Key | string | 章节名称的多语言Key | "chapter_001_name" |
| 剧情Key | string | 剧情文本的多语言Key | "chapter_001_story" |
| 章节编号 | number | 章节编号（1, 2, 3...） | 1 |
| 地图ID列表 | string | 该章节包含的地图ID列表（以\|分隔） | "map_001\|map_002" |
| 解锁任务ID | string | 解锁该章节所需的任务ID（上一章节的结束任务） | "quest_chapter_end_001" |
| 优先级 | number | 优先级（用于排序） | 1 |

#### 22.4.2 章节地图关联

- **地图配置扩展**：
  - 在 `MapConfig` 中新增字段 `所属章节ID` 和 `地图索引`
  - 或创建独立的 `ChapterMapConfig` 配置表，关联章节和地图

- **地图加载规则**：
  - 根据当前章节和地图索引加载对应的地图配置
  - 未解锁的地图不加载到游戏中

### 22.5 章节系统实现要点

#### 22.5.1 章节状态管理

- **状态维护**：
  - 维护当前所有章节的状态（未解锁、已解锁、进行中、已完成）
  - 使用 Map<string, Chapter> 存储章节，key 为 chapterId

- **状态持久化**：
  - 章节状态需要保存到存档中
  - 包括：当前章节ID、已解锁章节列表、已完成章节列表

#### 22.5.2 章节解锁检查

- **任务完成监听**：
  - 监听任务完成事件
  - 检查完成的任务是否为章节结束任务
  - 如果是，触发章节解锁流程

- **章节切换**：
  - 解锁新章节后，自动切换到新章节的第一张地图
  - 加载新章节的地图配置
  - 重置探险队位置（可选：保留或重置）

#### 22.5.3 剧情展示组件

- **ChapterStoryPanel 组件**：
  - 使用 React 创建
  - 全屏或半屏遮罩显示
  - 显示章节名称和剧情文本
  - 提供"继续"按钮关闭剧情界面
  - 支持多段剧情文本（分段显示或滚动显示）

### 22.6 章节系统与现有系统的集成

#### 22.6.1 与任务系统集成

- 任务配置中新增字段 `是否章节结束任务`（isChapterEndQuest）
- 当章节结束任务完成时，触发章节解锁
- 章节解锁任务作为特殊的任务类型

#### 22.6.2 与地图系统集成

- 根据当前章节加载对应的地图配置
- 地图切换时更新 `MapSystem` 实例
- 保留或重置探险队位置（根据设计决定）

#### 22.6.3 与存档系统集成

- 章节状态需要保存到存档中
- 包括：当前章节ID、已解锁章节列表、已完成章节列表
- 读档时恢复章节状态和当前地图

---

## 23. 装备系统设计

### 23.1 装备系统概述

装备系统允许角色装备特定数量的装备，装备的主要功能是用于探索棋盘中激活进阶产出效果。每个角色可以装备"N"个装备（N为角色属性中的装备槽位数量）。

装备系统与核心循环的关系：
- **装备管理**：在避难所或角色界面中管理装备的穿戴和卸下
- **探索效果**：装备在探索棋盘中的进阶产出机制评估时生效
- **装备限制**：每个角色有固定的装备槽位数量，不能超过

### 23.2 装备机制设计

#### 23.2.1 装备槽位

- **槽位数量**：
  - 每个角色有固定的装备槽位数量（`equipmentSlots`）
  - 装备槽位数量作为角色属性，在角色配置表中定义
  - 角色可以装备的装备数量不能超过槽位数量

- **装备状态**：
  - 每个装备槽位可以装备一个装备，也可以为空
  - 装备可以随时穿戴和卸下
  - 卸下的装备返回角色背包（如果背包有空间）

#### 23.2.2 装备效果

- **效果类型**：
  - 装备主要用于激活探索棋盘中的进阶产出机制
  - 装备效果在进阶产出条件评估时生效
  - 支持多种效果类型（如：增加特定垃圾类型的触发概率、提供特定标签等）

- **效果评估时机**：
  - 在探索棋盘生成后，处理垃圾产出时
  - 在 `AdvancedOutputEvaluationContext` 中考虑角色的装备效果
  - 装备效果影响进阶产出机制的触发条件判断

#### 23.2.3 装备与进阶产出机制

- **装备标签系统**：
  - 装备可以拥有"标签"（如：工具、武器、防护等）
  - 进阶产出机制可以通过检查角色装备的标签来触发
  - 例如：当队伍中有2个角色装备了"工具"标签的装备时，触发特定进阶产出

- **装备类型匹配**：
  - 装备可以匹配特定的垃圾类型
  - 当角色装备了匹配的装备时，更容易触发对应垃圾类型的进阶产出

### 23.3 装备数据结构

```csharp
// 伪代码结构
Equipment {
    string equipmentId;          // 装备ID
    string nameKey;              // 装备名称（多语言Key）
    string descKey;               // 装备描述（多语言Key）
    string[] tags;                // 装备标签列表（如：工具、武器、防护等）
    string[] matchedGarbageTypes; // 匹配的垃圾类型列表
    EquipmentEffect effect;       // 装备效果
    int maxStack;                 // 堆叠最大数量（如果装备可以作为道具）
}

EquipmentEffect {
    EffectType type;              // 效果类型
    Dictionary<string, object> params; // 效果参数
}

EffectType {
    ProvideTag,           // 提供标签（用于进阶产出条件检查）
    MatchGarbageType,     // 匹配垃圾类型
    BoostAdvancedOutput   // 提升进阶产出概率
}
```

### 23.4 角色数据结构扩展

```csharp
Explorer {
    // ... 现有字段 ...
    int equipmentSlots;           // 装备槽位数量（从配置表读取）
    string[] equipment;           // 当前装备的装备ID列表（长度 <= equipmentSlots）
}
```

### 23.5 装备配置表设计

#### 23.5.1 装备配置表 (EquipmentConfig)

**字段定义**：

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| ID | string | 装备ID（唯一标识） | "equipment_tool_001" |
| 名称Key | string | 装备名称的多语言Key | "equipment_tool_001_name" |
| 描述Key | string | 装备描述的多语言Key | "equipment_tool_001_desc" |
| 装备标签列表 | string | 装备标签列表（以\|分隔） | "工具\|金属" |
| 匹配垃圾类型列表 | string | 匹配的垃圾类型列表（以\|分隔） | "废金属\|电子元件" |
| 效果类型 | string | 效果类型 | "ProvideTag" |
| 效果参数 | string | 效果参数（JSON字符串或键值对） | "Tag=工具;Boost=0.1" |
| 堆叠最大数量 | number | 堆叠最大数量（如果装备可以作为道具） | 1 |

### 23.6 进阶产出机制扩展

#### 23.6.1 新增触发条件类型

- **EquipmentCount**（装备数量）：
  - 参数示例："EquipmentTag=工具;MinCount=2"
  - 逻辑：统计 explorers 中装备了指定标签装备的角色数量，数量 >= MinCount 则返回 true

- **EquipmentMatchGarbageType**（装备匹配垃圾类型）：
  - 参数示例："GarbageType=废金属;MinCount=1"
  - 逻辑：统计 explorers 中装备了匹配指定垃圾类型装备的角色数量，数量 >= MinCount 则返回 true

### 23.7 装备系统实现要点

#### 23.7.1 装备管理

- **穿戴装备**：
  - 检查角色装备槽位是否已满
  - 检查装备是否在角色背包中
  - 将装备从背包移除，添加到装备槽位

- **卸下装备**：
  - 将装备从装备槽位移除
  - 尝试将装备放回角色背包（如果背包有空间）
  - 如果背包已满，装备保留在槽位中（或提示玩家）

#### 23.7.2 装备效果应用

- **进阶产出评估**：
  - 在 `AdvancedOutputEvaluationContext` 中包含角色的装备信息
  - 在进阶产出条件处理器中检查装备标签和效果
  - 根据装备效果调整进阶产出触发条件

#### 23.7.3 装备界面

- **装备管理界面**：
  - 在角色详情或背包界面中显示装备槽位
  - 支持拖拽或点击穿戴/卸下装备
  - 显示装备效果和标签

### 23.8 装备系统与现有系统的集成

#### 23.8.1 与角色系统集成

- 角色配置表中添加 `装备槽位数量` 字段
- 角色数据结构中添加 `equipment` 字段
- 角色初始化时设置装备槽位数量

#### 23.8.2 与探索系统集成

- 在探索棋盘生成时，考虑角色的装备效果
- 在进阶产出机制评估时，检查角色的装备标签和效果

#### 23.8.3 与背包系统集成

- 装备可以作为道具存储在背包中
- 穿戴装备时从背包移除，卸下时放回背包

#### 23.8.4 与存档系统集成

- 装备状态需要保存到存档中
- 包括：每个角色的装备列表

---

**文档结束**
